<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>School-Stream</title>
    <!-- React CDNs -->
    <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    <!-- Babel for JSX transpilation -->
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <!-- Tailwind CSS CDN -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Lucide-React UMD CDN -->
    <script src="https://unpkg.com/lucide-react@latest/dist/umd/lucide-react.js"></script>
</head>
<body>
    <div id="root"></div>
    <script type="text/babel">
        // Use global React and lucideReact instead of imports
        const { useState, useEffect, useRef } = React;
        const { Upload, Play, Trash2, Video: VideoIcon, X: XIcon, Cloud, Settings, AlertCircle, CheckCircle, Loader, Zap, Info } = lucideReact || {}; // Fallback if lucide fails

        console.log('App loading...'); // Debug log to confirm script runs

        // Note: window.storage is assumed to be available; if running in browser, replace with localStorage wrappers
        if (!window.storage) {
            window.storage = {
                get: async (key) => ({ value: localStorage.getItem(key) }),
                set: async (key, value) => localStorage.setItem(key, value)
            };
        }

        const SchoolStream = () => {
          const [videos, setVideos] = useState([]);
          const [currentVideo, setCurrentVideo] = useState(null);
          const [uploadQueue, setUploadQueue] = useState([]);
          const [currentUpload, setCurrentUpload] = useState(null);
          const [showSettings, setShowSettings] = useState(false);
          const [compressionQuality, setCompressionQuality] = useState('medium'); // low, medium, high
          const [cloudConfig, setCloudConfig] = useState({
            cloudName: '',
            uploadPreset: ''
          });
          const [setupComplete, setSetupComplete] = useState(false);
          const videoRef = useRef(null);
          const canvasRef = useRef(null);
          const MAX_FILE_SIZE = 100 * 1024 * 1024; // 100MB
          useEffect(() => {
            loadVideos();
            loadConfig();
          }, []);
          useEffect(() => {
            if (uploadQueue.length > 0 && !currentUpload) {
              processNextUpload();
            }
          }, [uploadQueue, currentUpload]);
          const loadVideos = async () => {
            try {
              const result = await window.storage.get('school-stream-videos');
              if (result && result.value) {
                setVideos(JSON.parse(result.value));
              }
            } catch (error) {
              console.log('No existing videos found');
            }
          };
          const saveVideos = async (videoList) => {
            try {
              await window.storage.set('school-stream-videos', JSON.stringify(videoList));
            } catch (error) {
              console.error('Error saving videos:', error);
            }
          };
          const loadConfig = async () => {
            try {
              const result = await window.storage.get('cloud-config');
              if (result && result.value) {
                const config = JSON.parse(result.value);
                setCloudConfig(config);
                setSetupComplete(config.cloudName && config.uploadPreset);
              }
            } catch (error) {
              console.log('No config found');
            }
          };
          const saveConfig = async (config) => {
            try {
              await window.storage.set('cloud-config', JSON.stringify(config));
              setCloudConfig(config);
              setSetupComplete(config.cloudName && config.uploadPreset);
            } catch (error) {
              console.error('Error saving config:', error);
            }
          };
          const compressVideo = async (file, quality, onProgress) => {
            return new Promise((resolve, reject) => {
              const video = document.createElement('video');
              const canvas = document.createElement('canvas');
              const ctx = canvas.getContext('2d');
             
              // New: Set up AudioContext for audio routing
              const audioCtx = new AudioContext();
              let audioSource;
              let destination;
             
              video.preload = 'metadata';
             
              video.onloadedmetadata = async () => {
                try {
                  const duration = video.duration;
                 
                  // Quality settings
                  const qualitySettings = {
                    low: { scale: 0.5, bitrate: 500000, fps: 24 },
                    medium: { scale: 0.65, bitrate: 1000000, fps: 30 },
                    high: { scale: 0.8, bitrate: 2000000, fps: 30 }
                  };
                 
                  const settings = qualitySettings[quality];
                 
                  // Set canvas dimensions
                  canvas.width = video.videoWidth * settings.scale;
                  canvas.height = video.videoHeight * settings.scale;
                 
                  const stream = canvas.captureStream(settings.fps);
                 
                  // New: Create audio source and destination if audio exists
                  if (video.audioTracks && video.audioTracks.length > 0) {
                    await audioCtx.resume(); // Ensure context is running
                    destination = audioCtx.createMediaStreamDestination();
                    audioSource = audioCtx.createMediaElementSource(video);
                    audioSource.connect(destination);
                  }
                 
                  // New: Combine video and audio tracks
                  const videoTrack = stream.getVideoTracks()[0];
                  const tracks = [videoTrack];
                  if (destination) {
                    const audioTrack = destination.stream.getAudioTracks()[0];
                    tracks.push(audioTrack);
                  }
                  const combinedStream = new MediaStream(tracks);
                 
                  // Updated: Use combinedStream and add audio codec
                  const mediaRecorder = new MediaRecorder(combinedStream, {
                    mimeType: 'video/webm;codecs=vp8,opus', // vp8 for video, opus for audio
                    videoBitsPerSecond: settings.bitrate,
                    audioBitsPerSecond: 128000 // Adjustable audio bitrate
                  });
                 
                  const chunks = [];
                  let processedTime = 0;
                 
                  mediaRecorder.ondataavailable = (e) => {
                    if (e.data.size > 0) {
                      chunks.push(e.data);
                    }
                  };
                 
                  mediaRecorder.onstop = () => {
                    const blob = new Blob(chunks, { type: 'video/webm' });
                    const compressedFile = new File([blob], file.name.replace(/\.[^.]+$/, '.webm'), {
                      type: 'video/webm'
                    });
                    // New: Clean up audio resources
                    if (audioSource) {
                      audioSource.disconnect();
                    }
                    if (destination) {
                      destination.disconnect();
                    }
                    audioCtx.close();
                    resolve(compressedFile);
                  };
                 
                  mediaRecorder.onerror = (e) => reject(e);
                 
                  mediaRecorder.start();
                  video.play();
                 
                  const captureFrame = () => {
                    if (video.currentTime >= duration) {
                      mediaRecorder.stop();
                      video.pause();
                      return;
                    }
                   
                    ctx.drawImage(video, 0, 0, canvas.width, canvas.height);
                    processedTime = video.currentTime;
                   
                    const progress = (processedTime / duration) * 100;
                    onProgress({
                      phase: 'compressing',
                      percent: progress,
                      currentTime: processedTime,
                      totalTime: duration
                    });
                   
                    requestAnimationFrame(captureFrame);
                  };
                 
                  // Updated: Start capture loop immediately after play (more reliable than relying solely on timeupdate)
                  video.onplay = () => {
                    requestAnimationFrame(captureFrame);
                  };
                  video.ontimeupdate = captureFrame; // Keep as fallback
                 
                } catch (error) {
                  reject(error);
                }
              };
             
              video.onerror = () => reject(new Error('Error loading video'));
              video.src = URL.createObjectURL(file);
            });
          };
          const uploadToCloudinary = async (file, onProgress) => {
            return new Promise((resolve, reject) => {
              const xhr = new XMLHttpRequest();
              const formData = new FormData();
             
              formData.append('file', file);
              formData.append('upload_preset', cloudConfig.uploadPreset);
              formData.append('resource_type', 'video');
              formData.append('eager', 'f_mp4,vc_h264,ac_aac');
             
              xhr.upload.addEventListener('progress', (e) => {
                if (e.lengthComputable) {
                  const percentComplete = (e.loaded / e.total) * 100;
                  const elapsed = (Date.now() - xhr.startTime) / 1000;
                  const speed = e.loaded / elapsed;
                  const timeRemaining = (e.total - e.loaded) / speed;
                 
                  onProgress({
                    phase: 'uploading',
                    percent: percentComplete,
                    loaded: e.loaded,
                    total: e.total,
                    speed: speed,
                    timeRemaining: timeRemaining
                  });
                }
              });
              xhr.addEventListener('load', () => {
                if (xhr.status === 200) {
                  resolve(JSON.parse(xhr.responseText));
                } else {
                  reject(new Error('Upload failed: ' + xhr.statusText));
                }
              });
              xhr.addEventListener('error', () => reject(new Error('Network error')));
              xhr.addEventListener('abort', () => reject(new Error('Upload cancelled')));
              xhr.startTime = Date.now();
              xhr.open('POST', `https://api.cloudinary.com/v1_1/${cloudConfig.cloudName}/video/upload`);
              xhr.send(formData);
            });
          };
          const processNextUpload = async () => {
            const upload = uploadQueue[0];
            if (!upload) return;
            setCurrentUpload({...upload, phase: 'preparing', progress: 0});
            try {
              let fileToUpload = upload.file;
              const needsCompression = upload.file.size > MAX_FILE_SIZE;
             
              if (needsCompression) {
                setCurrentUpload(prev => ({
                  ...prev,
                  phase: 'compressing',
                  originalSize: upload.file.size,
                  needsCompression: true
                }));
               
                fileToUpload = await compressVideo(upload.file, compressionQuality, (progress) => {
                  setCurrentUpload(prev => ({
                    ...prev,
                    phase: 'compressing',
                    progress: progress.percent,
                    currentTime: progress.currentTime,
                    totalTime: progress.totalTime
                  }));
                });
               
                setCurrentUpload(prev => ({
                  ...prev,
                  compressedSize: fileToUpload.size,
                  compressionRatio: ((1 - fileToUpload.size / upload.file.size) * 100).toFixed(1)
                }));
              }
             
              // Upload to cloud
              const cloudinaryResponse = await uploadToCloudinary(fileToUpload, (progress) => {
                setCurrentUpload(prev => ({
                  ...prev,
                  phase: progress.phase,
                  progress: progress.percent,
                  loaded: progress.loaded,
                  total: progress.total,
                  speed: progress.speed,
                  timeRemaining: progress.timeRemaining
                }));
              });
              const playbackUrl = cloudinaryResponse.secure_url.replace(/\.(mkv|avi|mov|wmv|flv|webm)$/i, '.mp4');
              const videoData = {
                id: cloudinaryResponse.public_id,
                name: upload.file.name,
                originalSize: upload.file.size,
                compressedSize: needsCompression ? fileToUpload.size : null,
                url: playbackUrl,
                cloudUrl: cloudinaryResponse.secure_url,
                thumbnail: cloudinaryResponse.secure_url.replace('/upload/', '/upload/w_400,h_225,c_fill/') + '.jpg',
                uploadDate: new Date().toLocaleString(),
                isCloud: true,
                wasCompressed: needsCompression,
                format: cloudinaryResponse.format
              };
              const newVideos = [...videos, videoData];
              setVideos(newVideos);
              await saveVideos(newVideos);
              setUploadQueue(prev => prev.slice(1));
              setCurrentUpload(null);
            } catch (error) {
              alert(`Error processing ${upload.file.name}: ${error.message}`);
              setUploadQueue(prev => prev.slice(1));
              setCurrentUpload(null);
            }
          };
          const handleFileUpload = (e) => {
            if (!setupComplete) {
              alert('Please configure cloud storage in Settings first!');
              setShowSettings(true);
              return;
            }
            const files = Array.from(e.target.files);
           
            const newUploads = files
              .filter(file => file.type.startsWith('video/') ||
                ['.mp4', '.mkv', '.avi', '.mov', '.wmv', '.flv', '.webm', '.m4v'].some(ext =>
                  file.name.toLowerCase().endsWith(ext)))
              .map((file, index) => ({
                id: Date.now() + Math.random() + index,
                file: file,
                name: file.name,
                size: file.size,
                needsCompression: file.size > MAX_FILE_SIZE,
                progress: 0,
                status: 'queued'
              }));
            if (newUploads.length === 0) {
              alert('Please select valid video files');
              return;
            }
            setUploadQueue(prev => [...prev, ...newUploads]);
            e.target.value = '';
          };
          const cancelUpload = (uploadId) => {
            if (currentUpload && currentUpload.id === uploadId) {
              setCurrentUpload(null);
              setUploadQueue(prev => prev.slice(1));
            } else {
              setUploadQueue(prev => prev.filter(u => u.id !== uploadId));
            }
          };
          const deleteVideo = async (id) => {
            const newVideos = videos.filter(v => v.id !== id);
            setVideos(newVideos);
            await saveVideos(newVideos);
            if (currentVideo?.id === id) {
              setCurrentVideo(null);
            }
          };
          const formatFileSize = (bytes) => {
            if (bytes === 0) return '0 Bytes';
            const k = 1024;
            const sizes = ['Bytes', 'KB', 'MB', 'GB'];
            const i = Math.floor(Math.log(bytes) / Math.log(k));
            return Math.round(bytes / Math.pow(k, i) * 100) / 100 + ' ' + sizes[i];
          };
          const formatSpeed = (bytesPerSecond) => {
            return formatFileSize(bytesPerSecond) + '/s';
          };
          const formatTime = (seconds) => {
            if (!seconds || !isFinite(seconds)) return '--';
            const mins = Math.floor(seconds / 60);
            const secs = Math.floor(seconds % 60);
            return `${mins}m ${secs}s`;
          };
          return (
            <div className="min-h-screen bg-gradient-to-br from-gray-900 via-blue-900 to-gray-900">
              {/* Header */}
              <div className="bg-black bg-opacity-50 backdrop-blur-sm border-b border-blue-500">
                <div className="max-w-7xl mx-auto px-4 py-6">
                  <div className="flex items-center justify-between">
                    <div className="flex items-center gap-3">
                      <VideoIcon className="w-8 h-8 text-blue-400" />
                      <h1 className="text-3xl font-bold text-white">School-Stream</h1>
                    </div>
                    <div className="flex items-center gap-4">
                      <div className="text-sm text-blue-300">
                        {videos.length} video{videos.length !== 1 ? 's' : ''}
                        {setupComplete ? (
                          <span className="ml-2 text-green-400">
                            <Cloud className="w-4 h-4 inline" /> Cloud Active
                          </span>
                        ) : (
                          <span className="ml-2 text-yellow-400">
                            <AlertCircle className="w-4 h-4 inline" /> Setup Required
                          </span>
                        )}
                      </div>
                      <button
                        onClick={() => setShowSettings(!showSettings)}
                        className="bg-blue-600 hover:bg-blue-700 text-white px-4 py-2 rounded-lg transition-colors flex items-center gap-2"
                      >
                        <Settings className="w-4 h-4" />
                        Settings
                      </button>
                    </div>
                  </div>
                </div>
              </div>
              <div className="max-w-7xl mx-auto px-4 py-8">
                {/* Setup Banner */}
                {!setupComplete && (
                  <div className="mb-8 bg-yellow-900 bg-opacity-50 border-2 border-yellow-500 rounded-lg p-6">
                    <div className="flex items-start gap-4">
                      <AlertCircle className="w-8 h-8 text-yellow-400 flex-shrink-0 mt-1" />
                      <div className="flex-1">
                        <h3 className="text-xl font-bold text-yellow-300 mb-2">Cloud Storage Setup Required</h3>
                        <p className="text-yellow-200 mb-4">
                          Configure Cloudinary to upload videos with automatic compression and format conversion.
                        </p>
                        <button
                          onClick={() => setShowSettings(true)}
                          className="bg-yellow-600 hover:bg-yellow-700 text-white px-6 py-3 rounded-lg transition-colors font-semibold"
                        >
                          Configure Now (Free)
                        </button>
                      </div>
                    </div>
                  </div>
                )}
                {/* Settings Panel */}
                {showSettings && (
                  <div className="mb-8 bg-gray-800 bg-opacity-90 backdrop-blur-sm rounded-lg p-6 border border-blue-500">
                    <h2 className="text-xl font-bold text-white mb-4 flex items-center gap-2">
                      <Cloud className="w-5 h-5" />
                      Cloud Storage & Compression Settings
                    </h2>
                   
                    <div className="space-y-4">
                      {/* Compression Quality */}
                      <div className="bg-purple-900 bg-opacity-30 border border-purple-500 rounded-lg p-4">
                        <h3 className="text-white font-semibold mb-3 flex items-center gap-2">
                          <Zap className="w-5 h-5 text-purple-400" />
                          Video Compression Quality
                        </h3>
                        <p className="text-purple-200 text-sm mb-3">
                          Videos over 100MB will be automatically compressed before upload
                        </p>
                        <div className="grid grid-cols-3 gap-3">
                          <button
                            onClick={() => setCompressionQuality('low')}
                            className={`p-3 rounded-lg border-2 transition-all ${
                              compressionQuality === 'low'
                                ? 'border-purple-400 bg-purple-600'
                                : 'border-gray-600 bg-gray-700 hover:border-purple-500'
                            }`}
                          >
                            <div className="text-white font-semibold">Low Quality</div>
                            <div className="text-xs text-gray-300 mt-1">Smallest size</div>
                            <div className="text-xs text-gray-400">~30-40MB</div>
                          </button>
                          <button
                            onClick={() => setCompressionQuality('medium')}
                            className={`p-3 rounded-lg border-2 transition-all ${
                              compressionQuality === 'medium'
                                ? 'border-purple-400 bg-purple-600'
                                : 'border-gray-600 bg-gray-700 hover:border-purple-500'
                            }`}
                          >
                            <div className="text-white font-semibold">Medium Quality</div>
                            <div className="text-xs text-gray-300 mt-1">Balanced</div>
                            <div className="text-xs text-gray-400">~50-70MB</div>
                          </button>
                          <button
                            onClick={() => setCompressionQuality('high')}
                            className={`p-3 rounded-lg border-2 transition-all ${
                              compressionQuality === 'high'
                                ? 'border-purple-400 bg-purple-600'
                                : 'border-gray-600 bg-gray-700 hover:border-purple-500'
                            }`}
                          >
                            <div className="text-white font-semibold">High Quality</div>
                            <div className="text-xs text-gray-300 mt-1">Best quality</div>
                            <div className="text-xs text-gray-400">~80-95MB</div>
                          </button>
                        </div>
                      </div>
                      {/* Cloudinary Config */}
                      <div className="bg-blue-900 bg-opacity-30 border border-blue-500 rounded-lg p-4">
                        <div className="flex gap-2 mb-2">
                          <Info className="w-5 h-5 text-blue-400 flex-shrink-0" />
                          <div className="text-sm text-blue-300">
                            <p className="font-semibold mb-2">Cloudinary Setup:</p>
                            <ol className="list-decimal list-inside space-y-1">
                              <li>Sign up at cloudinary.com (free)</li>
                              <li>Get your Cloud Name from dashboard</li>
                              <li>Settings ‚Üí Upload ‚Üí Upload presets</li>
                              <li>Create preset with "Unsigned" mode</li>
                            </ol>
                          </div>
                        </div>
                      </div>
                      <div>
                        <label className="block text-blue-300 mb-2 font-semibold">Cloud Name *</label>
                        <input
                          type="text"
                          value={cloudConfig.cloudName}
                          onChange={(e) => setCloudConfig({...cloudConfig, cloudName: e.target.value})}
                          placeholder="your-cloud-name"
                          className="w-full bg-gray-700 text-white px-4 py-3 rounded-lg border border-blue-500 focus:border-blue-400 focus:outline-none"
                        />
                      </div>
                      <div>
                        <label className="block text-blue-300 mb-2 font-semibold">Upload Preset *</label>
                        <input
                          type="text"
                          value={cloudConfig.uploadPreset}
                          onChange={(e) => setCloudConfig({...cloudConfig, uploadPreset: e.target.value})}
                          placeholder="your-upload-preset"
                          className="w-full bg-gray-700 text-white px-4 py-3 rounded-lg border border-blue-500 focus:border-blue-400 focus:outline-none"
                        />
                      </div>
                      <div className="flex gap-3">
                        <button
                          onClick={() => {
                            if (cloudConfig.cloudName && cloudConfig.uploadPreset) {
                              saveConfig(cloudConfig);
                              setShowSettings(false);
                            } else {
                              alert('Please fill in both Cloud Name and Upload Preset');
                            }
                          }}
                          className="flex-1 bg-green-600 hover:bg-green-700 text-white px-4 py-3 rounded-lg transition-colors font-semibold flex items-center justify-center gap-2"
                        >
                          <CheckCircle className="w-5 h-5" />
                          Save Settings
                        </button>
                        <button
                          onClick={() => setShowSettings(false)}
                          className="bg-gray-600 hover:bg-gray-700 text-white px-6 py-3 rounded-lg transition-colors"
                        >
                          Cancel
                        </button>
                      </div>
                    </div>
                  </div>
                )}
                {/* Upload Queue */}
                {(currentUpload || uploadQueue.length > 0) && (
                  <div className="mb-8 bg-gray-800 bg-opacity-90 backdrop-blur-sm rounded-lg p-6 border border-blue-500">
                    <h2 className="text-xl font-bold text-white mb-4 flex items-center gap-2">
                      <Loader className="w-5 h-5 animate-spin" />
                      {currentUpload?.phase === 'compressing' ? 'Compressing & Uploading' : 'Upload Progress'}
                    </h2>
                   
                    {currentUpload && (
                      <div className="bg-gray-700 rounded-lg p-4 mb-4 border-2 border-blue-400">
                        <div className="flex items-center justify-between mb-3">
                          <div className="flex-1 min-w-0">
                            <span className="text-white font-semibold truncate block">{currentUpload.name}</span>
                            <span className="text-blue-300 text-sm">
                              {currentUpload.phase === 'compressing' && 'üîÑ Compressing video...'}
                              {currentUpload.phase === 'uploading' && '‚òÅÔ∏è Uploading to cloud...'}
                              {currentUpload.phase === 'preparing' && '‚öôÔ∏è Preparing...'}
                            </span>
                            {currentUpload.needsCompression && (
                              <div className="text-yellow-300 text-xs mt-1">
                                Original: {formatFileSize(currentUpload.originalSize)} ‚Üí Target: ~{formatFileSize(MAX_FILE_SIZE * 0.9)}
                              </div>
                            )}
                            {currentUpload.compressionRatio && (
                              <div className="text-green-300 text-xs mt-1">
                                ‚úì Compressed by {currentUpload.compressionRatio}% ({formatFileSize(currentUpload.compressedSize)})
                              </div>
                            )}
                          </div>
                          <button
                            onClick={() => cancelUpload(currentUpload.id)}
                            className="bg-red-600 hover:bg-red-700 text-white p-2 rounded transition-colors ml-4"
                          >
                            <XIcon className="w-4 h-4" />
                          </button>
                        </div>
                       
                        <div className="w-full bg-gray-600 rounded-full h-4 mb-3 overflow-hidden">
                          <div
                            className={`h-full transition-all duration-300 flex items-center justify-center text-xs font-bold text-white ${
                              currentUpload.phase === 'compressing' ? 'bg-purple-500' : 'bg-blue-500'
                            }`}
                            style={{ width: `${currentUpload.progress || 0}%` }}
                          >
                            {currentUpload.progress >= 10 && `${(currentUpload.progress || 0).toFixed(0)}%`}
                          </div>
                        </div>
                       
                        <div className="grid grid-cols-2 md:grid-cols-4 gap-2 text-sm">
                          <div className="bg-gray-600 rounded p-2">
                            <div className="text-gray-400 text-xs">Progress</div>
                            <div className="text-blue-300 font-semibold">{(currentUpload.progress || 0).toFixed(1)}%</div>
                          </div>
                          {currentUpload.phase === 'uploading' && (
                            <>
                              <div className="bg-gray-600 rounded p-2">
                                <div className="text-gray-400 text-xs">Uploaded</div>
                                <div className="text-blue-300 font-semibold text-xs">
                                  {formatFileSize(currentUpload.loaded || 0)}
                                </div>
                              </div>
                              <div className="bg-gray-600 rounded p-2">
                                <div className="text-gray-400 text-xs">Speed</div>
                                <div className="text-green-400 font-semibold text-xs">
                                  {currentUpload.speed ? formatSpeed(currentUpload.speed) : '--'}
                                </div>
                              </div>
                              <div className="bg-gray-600 rounded p-2">
                                <div className="text-gray-400 text-xs">Time Left</div>
                                <div className="text-yellow-400 font-semibold text-xs">
                                  {formatTime(currentUpload.timeRemaining)}
                                </div>
                              </div>
                            </>
                          )}
                        </div>
                      </div>
                    )}
                    {uploadQueue.length > (currentUpload ? 1 : 0) && (
                      <div className="space-y-2">
                        <h3 className="text-white font-semibold mb-2">Queue ({uploadQueue.length - (currentUpload ? 1 : 0)} waiting)</h3>
                        {uploadQueue.slice(currentUpload ? 1 : 0).map((upload) => (
                          <div key={upload.id} className="bg-gray-700 rounded-lg p-3 border border-gray-600 flex items-center justify-between">
                            <div className="flex-1 min-w-0">
                              <div className="text-white truncate">{upload.name}</div>
                              <div className="text-gray-400 text-sm">
                                {formatFileSize(upload.size)}
                                {upload.needsCompression && (
                                  <span className="text-yellow-400 ml-2">‚ö†Ô∏è Will compress</span>
                                )}
                              </div>
                            </div>
                            <button
                              onClick={() => cancelUpload(upload.id)}
                              className="bg-red-600 hover:bg-red-700 text-white p-2 rounded transition-colors ml-4"
                            >
                              <XIcon className="w-4 h-4" />
                            </button>
                          </div>
                        ))}
                      </div>
                    )}
                  </div>
                )}
                {/* Upload Area */}
                <div className="mb-8">
                  <label className={`flex flex-col items-center justify-center w-full h-48 border-2 border-dashed rounded-lg cursor-pointer transition-all ${
                    setupComplete
                      ? 'border-blue-400 bg-gray-800 bg-opacity-50 hover:bg-opacity-70'
                      : 'border-gray-600 bg-gray-800 bg-opacity-30 cursor-not-allowed'
                  }`}>
                    <div className="flex flex-col items-center justify-center pt-5 pb-6">
                      <Upload className={`w-12 h-12 mb-3 ${setupComplete ? 'text-blue-400' : 'text-gray-500'}`} />
                      <p className={`mb-2 text-lg ${setupComplete ? 'text-blue-300' : 'text-gray-500'}`}>
                        <span className="font-semibold">
                          {setupComplete ? 'Click to upload' : 'Configure settings first'}
                        </span>
                        {setupComplete && ' or drag and drop'}
                      </p>
                      <p className={`text-sm ${setupComplete ? 'text-blue-400' : 'text-gray-500'}`}>
                        {setupComplete ? 'Any video format - Large files auto-compressed!' : 'Setup required in Settings'}
                      </p>
                      {setupComplete && (
                        <div className="mt-2 text-center">
                          <p className="text-xs text-green-400">
                            ‚ú® Auto-compression for files over 100MB
                          </p>
                          <p className="text-xs text-purple-400">
                            Current quality: {compressionQuality.charAt(0).toUpperCase() + compressionQuality.slice(1)}
                          </p>
                        </div>
                      )}
                    </div>
                    <input
                      type="file"
                      className="hidden"
                      accept="video/*,.mkv,.avi,.mov,.wmv,.flv,.webm"
                      multiple
                      onChange={handleFileUpload}
                      disabled={!setupComplete}
                    />
                  </label>
                </div>
                {/* Video Player */}
                {currentVideo && (
                  <div className="mb-8 bg-black rounded-lg overflow-hidden shadow-2xl border border-blue-500">
                    <div className="flex items-center justify-between bg-gray-900 px-4 py-3 border-b border-blue-500">
                      <div className="flex items-center gap-2 flex-1 min-w-0">
                        <h3 className="text-white font-semibold truncate">{currentVideo.name}</h3>
                        {currentVideo.wasCompressed && (
                          <span className="bg-purple-600 text-white text-xs px-2 py-1 rounded flex-shrink-0">
                            <Zap className="w-3 h-3 inline" /> Compressed
                          </span>
                        )}
                        <span className="bg-green-600 text-white text-xs px-2 py-1 rounded flex-shrink-0 flex items-center gap-1">
                          <Cloud className="w-3 h-3" /> Cloud
                        </span>
                      </div>
                      <button
                        onClick={() => setCurrentVideo(null)}
                        className="text-blue-400 hover:text-blue-300 transition-colors ml-2"
                      >
                        <XIcon className="w-5 h-5" />
                      </button>
                    </div>
                    <video
                      key={currentVideo.id}
                      controls
                      autoPlay
                      playsInline
                      className="w-full"
                      style={{ maxHeight: '70vh' }}
                      src={currentVideo.url}
                      poster={currentVideo.thumbnail}
                    >
                      Your browser does not support the video tag.
                    </video>
                  </div>
                )}
                {/* Video Grid */}
                {videos.length === 0 ? (
                  <div className="text-center py-16">
                    <VideoIcon className="w-16 h-16 mx-auto mb-4 text-blue-400 opacity-50" />
                    <p className="text-blue-300 text-lg">No videos uploaded yet</p>
                    <p className="text-blue-400 text-sm mt-2">
                      {setupComplete
                        ? 'Upload your first video - large files will be auto-compressed!'
                        : 'Configure cloud storage in Settings to begin'}
                    </p>
                  </div>
                ) : (
                  <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-6">
                    {videos.map(video => (
                      <div
                        key={video.id}
                        className="bg-gray-800 bg-opacity-50 backdrop-blur-sm rounded-lg overflow-hidden border border-blue-500 hover:border-blue-400 transition-all shadow-lg hover:shadow-blue-500/50"
                      >
                        <div className="relative bg-black aspect-video flex items-center justify-center overflow-hidden">
                          {video.thumbnail ? (
                            <img
                              src={video.thumbnail}
                              alt={video.name}
                              className="w-full h-full object-cover"
                            />
                          ) : (
                            <VideoIcon className="w-16 h-16 text-blue-400 opacity-30" />
                          )}
                          <div className="absolute top-2 right-2 flex gap-1">
                            {video.wasCompressed && (
                              <span className="bg-purple-600 text-white text-xs px-2 py-1 rounded flex items-center gap-1">
                                <Zap className="w-3 h-3" />
                              </span>
                            )}
                            <span className="bg-green-600 text-white text-xs px-2 py-1 rounded flex items-center gap-1">
                              <Cloud className="w-3 h-3" />
                            </span>
                          </div>
                          <button
                            onClick={() => setCurrentVideo(video)}
                            className="absolute inset-0 flex items-center justify-center bg-black bg-opacity-0 hover:bg-opacity-50 transition-all group"
                          >
                            <div className="bg-blue-600 rounded-full p-4 opacity-0 group-hover:opacity-100 transition-opacity transform group-hover:scale-110">
                              <Play className="w-8 h-8 text-white fill-white" />
                            </div>
                          </button>
                        </div>
                       
                        <div className="p-4">
                          <h3 className="text-white font-semibold truncate mb-2">{video.name}</h3>
                          <div className="flex items-center justify-between text-sm text-blue-300 mb-2">
                            <span>{formatFileSize(video.originalSize)}</span>
                            <span className="text-xs">{video.uploadDate}</span>
                          </div>
                          {video.wasCompressed && (
                            <div className="bg-purple-900 bg-opacity-30 border border-purple-600 rounded p-2 mb-3">
                              <p className="text-purple-300 text-xs flex items-center gap-1">
                                <Zap className="w-3 h-3" />
                                Compressed: {formatFileSize(video.originalSize)} ‚Üí {formatFileSize(video.compressedSize)}
                              </p>
                            </div>
                          )}
                          <div className="bg-green-900 bg-opacity-30 border border-green-600 rounded p-2 mb-3">
                            <p className="text-green-300 text-xs flex items-center gap-1">
                              <CheckCircle className="w-3 h-3" />
                              Plays everywhere
                            </p>
                          </div>
                          <div className="flex gap-2">
                            <button
                              onClick={() => setCurrentVideo(video)}
                              className="flex-1 bg-blue-600 hover:bg-blue-700 text-white px-4 py-2 rounded-lg transition-colors flex items-center justify-center gap-2"
                            >
                              <Play className="w-4 h-4" />
                              Play
                            </button>
                            <button
                              onClick={() => deleteVideo(video.id)}
                              className="bg-red-600 hover:bg-red-700 text-white px-4 py-2 rounded-lg transition-colors"
                            >
                              <Trash2 className="w-4 h-4" />
                            </button>
                          </div>
                        </div>
                      </div>
                    ))}
                  </div>
                )}
              </div>
            </div>
          );
        };

        ReactDOM.render(<SchoolStream />, document.getElementById('root'));
    </script>
</body>
</html>